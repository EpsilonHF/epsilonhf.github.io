<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>深入理解 malloc | 寒枫的博客</title>
    <meta property="og:title" content="深入理解 malloc - 寒枫的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2019-08-19T00:00:00&#43;08:00">
        
        
    <meta property="article:modified_time" content="2019-08-19T00:00:00&#43;08:00">
        
    <meta name="Keywords" content="linux,c语言,机器学习,Hanfeng,寒枫,python,博客">
    <meta name="description" content="深入理解 malloc">
        <meta name="author" content="Hanfeng Zhang">
        
    <meta property="og:url" content="https://Hanfeng.ink/post/understand_glibc_malloc/">
    <link rel="shortcut icon" href="https://Hanfeng.ink/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="https://Hanfeng.ink/css/normalize.css">
    
        <link rel="stylesheet" href="https://Hanfeng.ink/css/prism.css">
    
    <link rel="stylesheet" href="https://Hanfeng.ink/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
        <link rel="stylesheet" href="https://Hanfeng.ink/css/douban.css">
    
        <link rel="stylesheet" href="https://Hanfeng.ink/css/other.css">
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://Hanfeng.ink/">
                        寒枫的博客
                    </a>
                
                <p class="description">业精于勤荒于嬉，行成于思毁于随</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://Hanfeng.ink/">首页</a>
                    
                    <a  href="https://Hanfeng.ink/archives/" title="归档">归档</a>
                    
                    <a  href="https://Hanfeng.ink/books/" title="推荐">推荐</a>
                    
                    <a  href="https://Hanfeng.ink/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">深入理解 malloc</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2019年8月19日
                        </date>
                        
                        <div class="post-meta">
                            <span>|</span>
                            
                                <span class="meta-category"><a href="https://Hanfeng.ink/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></span>
                            
                        </div>
                        
                        
                        <div class="post-meta">
                            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span> 阅读</span></span>
                        </div>
                        
                        <div class="post-content">
                            <p>本文是基于英文博客 <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/">Understanding glibc malloc</a> ，对内容做了大量的补充和修改，主要阐释了<code>malloc</code>分配内存的底层实现原理。</p>

<p>我一直在执着于堆的一些问题。比如以下问题：</p>

<ul>
<li>堆的内存怎样从内核中申请的？</li>
<li>怎样有效地进行内存管理？</li>
<li>堆内存是通过内核，库还是堆本身进行管理？</li>
<li>堆的一些相关问题能被利用吗？</li>
</ul>

<p>虽然之前经常在想这些问题，但是光想并没有什么用。正好，最近我找到了点时间来好好思考这些问题。所以现在我就来分享一下这些知识的总结。此外，还有很多可用的内存分配器：</p>

<ul>
<li><code>dlmalloc</code> – 通用分配器</li>
<li><code>ptmalloc2</code> – glibc</li>
<li><code>jemalloc</code> – FreeBSD and Firefox</li>
<li><code>tcmalloc</code>– Google</li>
<li><code>libumem</code> – Solaris</li>
</ul>

<p>每种内存分配器都声称自己速度快、可扩展、空间利用高效！！但是并非所有的分配器都适合我们的程序。内存消耗大的应用，其性能很大程度依赖于内存分配器的性能。本文仅讨论 <code>glibc malloc</code> 内存分配器。</p>

<h2 id="简介">简介</h2>

<p><a href="http://www.malloc.de/en/"><code>ptmalloc2</code></a>来自于 <a href="https://github.com/ennorehling/dlmalloc"><code>dlmalloc</code></a> 的分支。在其基础上添加线程支持并于 2006 年发布。正式发布后，<code>patmalloc2</code> 集成到 <code>glibc</code> 源码中。随着源码集成，代码修改便直接在 <code>glibc malloc</code> 源码里进行。因此 <code>ptmalloc2</code> 的实现与 <code>glibc malloc</code> 有很多不同。</p>

<p>在早期的<code>Linux</code> 里，<code>dlmalloc</code> 被用做默认的内存分配器。但之后因为 <code>ptmalloc2</code> 添加了线程支持，<code>ptmalloc2</code> 成为了 <code>Linux</code> 默认内存分配器。线程支持可帮助提升内存分配器以及应用程序的性能。在 <code>dlmalloc</code> 里，当两个线程同时调用 <code>malloc</code> 时，只有一个线程能进入到临界段，因为这里的空闲列表是所有可用线程共用的。因此内存分配器要在多线程应用里耗费时间，从而导致性能降低。然而在 <code>ptmalloc2</code> 里，当两个线程同时调用 <code>malloc</code> 时，会立即分配内存。因为每个线程维护一个单独的堆分段，因此空闲列表维护的这些堆也是独立的。这种维护独立堆以及每一个线程享有空闲列表数据结构的行为被称为 <code>Per Thread Arena</code>。</p>

<h2 id="malloc-的实现">malloc 的实现</h2>

<p><code>malloc</code> 有两种方式获取内存，分别为<code>sbrk</code> 和 <code>mmap</code> ，以下为示意图：</p>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/malloc.png" alt="malloc" /></p>

<p>我们来看一下关于这两个系统调用的官方解释：</p>

<p><code>sbrk</code>:</p>

<blockquote>
<p>The brk() function sets the break or lowest address of a process&rsquo;s data segment (uninitialized data) to addr (immediately above bss).  Data addressing is restricted between addr and the lowest stack pointer to the stack segment.</p>
</blockquote>

<p><code>mmap</code>:</p>

<blockquote>
<p>The mmap() system call causes the pages starting at addr and continuing for at most len bytes to be mapped from the object described by fd, starting at byte offset offset.</p>
</blockquote>

<p>两者一个明显区别在于，通过<code>sbrk</code>获得的新的堆的内存地址和之前的地址是连续的，而 <code>mmap</code> 获得的地址由参数设定。下图为内存分配的示意图：</p>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/space.png" alt="memmory" /></p>

<h2 id="内存分析方法">内存分析方法</h2>

<p>在进行进一步的分析之前，我们先要找到合适的方法，分析程序的内存分配情况。本文通过读取<code>/proc/$pid/maps</code>，该文件的具体内容可以通过 <code>man 5 proc</code>来了解，其的部分的解释如下：</p>

<pre><code>address           perms  offset    dev    inode       pathname
00400000-00452000 r-xp   00000000  08:02  173521      /usr/bin/dbus-daemon
00651000-00652000 r--p   00051000  08:02  173521      /usr/bin/dbus-daemon
00652000-00655000 rw-p   00052000  08:02  173521      /usr/bin/dbus-daemon
00e03000-00e24000 rw-p   00000000  00:00  0           [heap]
00e24000-011f7000 rw-p   00000000  00:00  0           [heap]
</code></pre>

<p><code>perms</code>代表了内存的权限，有5种格式：</p>

<ul>
<li><code>r</code> = read</li>
<li><code>w</code> = write</li>
<li><code>x</code> = execute</li>
<li><code>s</code> = shared</li>
<li><code>p</code> = private (copy on write)</li>
</ul>

<p><code>offset</code>字段是文件中的偏移量；<code>dev</code>是设备（主要：次要）；<code>inode</code>是该设备上的<code>inode</code>。 0表示没有<code>inode</code>与内存区域相关联，就像<code>.BSS</code>（未初始化的数据存放的<code>section</code>）</p>

<p><code>pathname</code>字段指向映射的文件。同时会提供几种伪地址：
- <code>[stack]</code>：进程的栈
- <code>[stack:&lt;tid&gt;]</code>：各个线程的栈
- <code>[vdso]</code>：虚拟动态共享对象
- <code>[heap]</code>：进程的堆</p>

<h2 id="具体分析">具体分析</h2>

<p>我们用C语言编写一个简单的程序，在其中调用 <code>malloc</code> 来动态分配内存，并使用 <code>getchar</code> 使程序暂停，帮助我们查看程序的内存分配具体情况，源代码如下：</p>

<pre><code class="language-c">/* Per thread arena example. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

void* threadFunc(void* arg) {
    printf(&quot;Before malloc in thread 1\n&quot;);
    getchar();
    char* addr = (char*) malloc(1000 * sizeof(char));
    printf(&quot;After malloc and before free in thread 1\n&quot;);
    getchar();
    free(addr);
    printf(&quot;After free in thread 1\n&quot;);
    getchar();
}

int main() {
    pthread_t t1;
    void* s;
    int ret;
    char* addr;

    printf(&quot;Welcome to per thread arena example::%d\n&quot;, getpid());
    printf(&quot;Before malloc in main thread\n&quot;);
    getchar();
    addr = (char*) malloc(6553500 * sizeof(char));
    printf(&quot;After malloc and before free in main thread\n&quot;);
    getchar()
    free(addr);
    printf(&quot;After free in main thread\n&quot;);
    getchar();
    ret = pthread_create(&amp;t1, NULL, threadFunc, NULL);
    if(ret) {
        printf(&quot;Thread creation error\n&quot;);
        return -1;
    }
    ret = pthread_join(t1, &amp;s);
    if(ret) {
        printf(&quot;Thread join error\n&quot;);
        return -1;
    }

    return 0;
}
</code></pre>

<p>我们运行程序，检测输出的内容：</p>

<pre><code>$ gcc main.c -lpthread -o mthread
$ ./mthread
Welcome to per thread arena example::13201
Before malloc in main thread
</code></pre>

<p>我们根据程序 <code>PID</code> 查看程序的内存分配情况：</p>

<pre><code>$ cat /proc/13140/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794              /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794              /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794              /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                   [heap]
...
</code></pre>

<p>此时主进程并没有调用<code>malloc</code>，但进程已经初始化部分内存空间作为进程的堆，地址为<code>56424c8db000-56424c8fc000</code>，大小为132KB。这个堆内存的连续区域被称为<code>arena</code>。这个 <code>arena</code> 是由主线程创建，则被称为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1740"><code>main arena</code></a>。进一步的分配请求会继续使用这个 <code>arena</code> 直到 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3788"><code>arena 空闲空间耗尽</code></a>。：</p>

<pre><code>...
After malloc and before free in main thread
...
$ cat /proc/13201/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794              /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794              /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794              /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                   [heap]
7f6075cd0000-7f6076310000 rw-p 00000000 00:00 0
...
</code></pre>

<p>由于我们在使用<code>malloc</code>申请了一块较大的地址，原有的堆空间无法满足需求，因此会使用 <code>mmap</code> 系统调用，进一步扩张<code>arena</code>的区域，新申请的内存区域与之前的堆相连，地址为<code>7f6075cd0000-7f6076310000</code> 。接着主线程<code>free</code>内存块。</p>

<pre><code>...
After free in main thread
...
$ cat /proc/13201/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794              /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794              /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794              /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                   [heap]
...
</code></pre>

<p>在主线程 <code>free</code> 之后： 在上面的输出里我们可以看到，当分配内存区域被释放时，其后内存不会被立即释放给操作系统。分配内存区域（1000 bytes 大小）只释放给 <code>glibc malloc</code> 库，在这里的释放掉的 <code>Chunk</code> 会被添加到 <code>main arenas</code> 中（在<code>glibc malloc</code> 里，<code>freelist</code> 被称为 <code>bins</code>）。此后当用户申请内存时，<code>glibc malloc</code> 不会从内核中获得新的堆内存，而是尽量在<code>bins</code> 里找到一个空闲块(<code>Free Chunk</code>)。只有当没有空闲块存在时，<code>glibc malloc</code> 才会从继续内核中申请内存。</p>

<pre><code>...
Before malloc in thread 1
...
$ cat /proc/13201/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794              /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794              /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794              /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                   [heap]
7f6075b0f000-7f6075b10000 ---p 00000000 00:00 0
7f6075b10000-7f6076310000 rw-p 00000000 00:00 0
...
</code></pre>

<p>接着我们创建线程，我们可以看到，在线程调用<code>malloc</code>之前，已经为线程分配好了线程堆，其地址为<code>7f6075b10000-7f6076310000</code>。我们可以看到线程堆的地址进程堆的地址并不连续，这表明堆内存通过使用 <code>mmap</code> 系统调用而不是主线程（使用 <code>sbrk</code>）创建。</p>

<pre><code>...
After malloc and before free in thread 1
...
$ cat /proc/13201/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794              /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794              /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794              /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                   [heap]
7f6070000000-7f6070031000 rw-p 00000000 00:00 0
7f6070031000-7f6074000000 ---p 00000000 00:00 0
7f6075b0f000-7f6075b10000 ---p 00000000 00:00 0
7f6075b10000-7f6076310000 rw-p 00000000 00:00 0
...
</code></pre>

<p>在线程<code>malloc</code>之后，出现一个新的线程堆地址，其中<code>7f6070000000-7f6070031000</code> 有读写权限，<code>7f6070031000-7f6074000000</code>仅支持写时拷贝(<code>copy on write</code>)。<code>7f6070000000-7f6070031000</code>这块内存区域被称为<code>thread arena</code>。</p>

<p>注意：当用户申请的内存大小超过 128KB（ <code>malloc(132*1024)</code> ）并且当一个<code>arena</code> 里没有足够的空间来满足用户的请求时，内存是使用 <code>mmap</code> 系统调用来分配的（不使用 <code>sbrk</code>） 无论这个请求是来自于 <code>main arena</code> 还是 <code>thread arena</code>。</p>

<pre><code>...
After free in thread 1
...
$ cat /proc/13201/maps
56424b4c2000-56424b4c3000 r-xp 00000000 08:01 673794                     /home/zhf/mthread
56424b6c2000-56424b6c3000 r--p 00000000 08:01 673794                     /home/zhf/mthread
56424b6c3000-56424b6c4000 rw-p 00001000 08:01 673794                     /home/zhf/mthread
56424c8db000-56424c8fc000 rw-p 00000000 00:00 0                          [heap]
7f6070000000-7f6070031000 rw-p 00000000 00:00 0
7f6070031000-7f6074000000 ---p 00000000 00:00 0
7f6075b0f000-7f6075b10000 ---p 00000000 00:00 0
7f6075b10000-7f6076310000 rw-p 00000000 00:00 0
...
</code></pre>

<p>在线程 <code>free</code> 之后后：在上面的输出我们可以看到，释放的堆内存并不会给操作系统。相反，这块内存区域还给了 <code>glibc malloc</code> 里，并将这个释放块添加到 <code>thread arenas</code> 的 <code>bins</code> 里，由 <code>freelist</code> 维护。</p>

<h2 id="arena-共享">Arena 共享</h2>

<p>在以上示例中，我们看到了主线程包含<code>main arena</code> 同时每个线程包含了它自己的 <code>thread arena</code>。那么是不是无论多少线程，每个线程都有自己独立的 <code>arena</code> 呢？显然不是，一个进程可以包含比 <code>CPU</code> 核数量更多的线程数量，在这样的情况下，每个线程单独有一个 <code>arena</code> ，其代价十分昂贵。因此，应用程序的<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">arena 数量的限制是基于系统里现有的 CPU 核的数量</a>。</p>

<pre><code>For 32 bit systems:
     Number of arena = 2 * number of cores.
For 64 bit systems:
     Number of arena = 8 * number of cores.
</code></pre>

<p>假设我们有一个多线程的程序（4线程 - 主线程 + 3个用户线程），在一个单核 32 位系统上运行。这里线程数量 &gt; 2 * 核心数量。因此，<code>glibc malloc</code> 认定 <code>Multiple Arena</code> 被所有可用进程共享。但它是怎样共享的呢？</p>

<ul>
<li>当主线程第一次调用 <code>malloc</code> 时，glibc malloc 会直接为它分配一个 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1740">main arena</a>，不需要任何的附加条件</li>
<li>当用户线程1和用户线程2第一次调用 <code>malloc</code> 时，会为这些线程<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L870">创建一个新的 arena</a> 。此时，各个线程与<code>arena</code>是一一对应的。</li>
<li>当户线程3第一次调用 <code>malloc</code> 时， 此时 <code>glibc malloc</code> 能维持的 <code>arena</code> 数量已到达上限，因此尝试<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L875">重用</a> 现存的 <code>arena</code> （<code>main arena</code> 、<code>arena 1</code> 或<code>arena 2</code>）。

<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L810">遍历了所有</a>可用的 <code>arena</code>，<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L805">尽量去</a>锁定可用的 <code>arena</code>。</li>
<li>如果锁定成功（我们假设说 <code>main arena</code> 被锁定成功），就向用户<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L826">返回</a>该 <code>arena</code>。</li>
<li>如果没有 <code>arena</code> 是空闲的，那么就将线程3的<code>malloc</code>操作 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L819">阻塞</a>，直到有可用的arena为止。。</li>
</ul></li>
<li>现在当用户线程3第二次调用 <code>malloc</code> 时，<code>malloc</code> 会<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L2884">尽量使用上次访问的 arena</a> （<code>main arena</code>）。如果 <code>main arena</code> 是空闲的， 用户线程3会一直使用该 <code>arena</code> 并屏蔽其他线程的申请直到 <code>main arena</code> 被释放。<code>main arena</code> 就是这样在主线程和用户线程3间共享。</li>
</ul>

<h2 id="堆结构">堆结构</h2>

<p>在 <code>glibc malloc</code> 源代码里主要发现以下三种数据结构：</p>

<ul>
<li><code>heap_info</code> —即 <code>heap header</code>，因为一个<code>thread arena</code>(注意：不包含<code>main thread</code>) 可以包含多个heaps，所以为了便于管理，就给每个heap分配一个<code>heap header</code>。那么在什么情况下一个 <code>thread arena</code> 会包含多个heaps呢。在当前heap不够用的时候，<code>malloc</code> 会通过系统调用<code>mmap</code> 申请新的堆空间，新的堆空间会被添加到当前<code>thread arena</code> 中，便于管理。</li>
</ul>

<pre><code class="language-C">typedef struct _heap_info
{
  	mstate ar_ptr; /* Arena for this heap. */
  	struct _heap_info *prev; /* Previous heap. */
  	size_t size;   /* Current size in bytes. */
  	size_t mprotect_size; /* Size in bytes that has been mprotected
                             PROT_READ|PROT_WRITE.  */
  	/* Make sure the following data is properly aligned, particularly
       that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
       MALLOC_ALIGNMENT. */
  	char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];
} heap_info;
</code></pre>

<ul>
<li><code>malloc_state</code> — 即<code>Arena Header</code>，每个线程只含有一个<code>Arena Header</code>。<code>Area Header</code> 包含bins信息，top chunk 以及 last remainder chunk 等。</li>
</ul>

<pre><code class="language-C">struct malloc_state
{
  	/* Serialize access.  */
  	mutex_t mutex;
 
  	/* Flags (formerly in max_fast).  */
  	int flags;
 
  	/* Fastbins */
  	mfastbinptr fastbinsY[NFASTBINS];
 
  	/* Base of the topmost chunk -- not otherwise kept in a bin */
  	mchunkptr top;
 
  	/* The remainder from the most recent split of a small request */
  	mchunkptr last_remainder;
 
  	/* Normal bins packed as described above */
  	mchunkptr bins[NBINS * 2 - 2];
 
  	/* Bitmap of bins */
  	unsigned int binmap[BINMAPSIZE];
 
  	/* Linked list */
  	struct malloc_state *next;
 
  	/* Linked list for free arenas.  */
  	struct malloc_state *next_free;
 
  	/* Memory allocated from the system in this arena.  */
  	INTERNAL_SIZE_T system_mem;
  	INTERNAL_SIZE_T max_system_mem;
};
</code></pre>

<ul>
<li><code>malloc_chunk</code> — 即<code>chunk header</code>。一个 header 被分为多个 chunk，至于每个chunk 的大小，由用户的请求决定，也就是说用户调用<code>malloc(size)</code>传递的<code>size</code>参数”就是”chunk的大小（这里给“就是”加上引号，说明这种表示并不正确，但是为了方便立即就暂时这么描述了）。每个chunk都由一个结构体<code>malloc_chunk</code>表示。</li>
</ul>

<pre><code class="language-C">
struct malloc_chunk {
  	/* #define INTERNAL_SIZE_T size_t */
  	INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  	INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */
  	struct malloc_chunk* fd;         /* double links -- used only if free. 这两个指针只在free chunk中存在*/
  	struct malloc_chunk* bk;
 
  	/* Only used for large blocks: pointer to next larger size.  */
  	struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  	struct malloc_chunk* bk_nextsize;
};
</code></pre>

<p>注意：</p>

<ul>
<li><p><code>Main arena</code> 没有多重堆，因此没有 <code>heap_info</code> 结构体。当 <code>main arena</code> 耗尽空间时，就通过扩展<code>sbrk</code> 的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p></li>

<li><p>不同于 <code>thread arena</code>，<code>main arena</code> 的 <code>Arena header</code> 不是 <code>sbrk sbrk heap segment</code> 堆分段的一部分。它是一个<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1740">全局变量</a>，因此它属于 lib.so 的 data segment。</p></li>
</ul>

<p>首先，通过内存分布图解释清<code>malloc_state</code> 与 <code>heap_info</code> 之间的组织关系。</p>

<p>下面是只有一个 heap segment 的 <code>main arena</code> 和 <code>thread arena</code> 的内存分布图：：</p>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/main_arena.png" alt="main_arena" /></p>

<p>下面是一个<code>thread arena</code>中含有多个 heap segments 的情况：</p>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/thread_arena.png" alt="thread_arena" /></p>

<p>上图可以看出，<code>thread arena</code> 只含有一个<code>malloc_state</code>（即arena header），却有两个<code>heap_info</code>(即heap header)。由于两个 heap segment 是通过 <code>mmap</code> 分配内存，两者 heap segments 是通过<code>mmap</code> 分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，<code>libc malloc</code> 将第二个<code>heap_info</code> 结构体的<code>prev</code> 成员指向第一个<code>heap_info</code> 结构体的起始位置（即<code>ar_ptr</code>成员），而第一个<code>heap_info</code> 结构体的<code>ar_ptr</code> 成员指向了<code>malloc_state</code>，这样就构成一个单链表，方便以后管理。</p>

<h2 id="chunk">Chunk</h2>

<p>在堆里的块可以是以下几种类型中的一种：</p>

<ul>
<li><code>Allocated chunk</code>—— 分配后的块</li>
<li><code>Free chunk</code> —— 空闲块</li>
<li><code>Top chunk</code> —— 开始块</li>
<li><code>Last Remainder chunk</code> —— 最后剩余块</li>
</ul>

<p>从本质上来说，所有类型的 chunk 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。为了简便，我们先将这4类 chunk 简化为2类：<code>allocate chunk</code>以及<code>free chunk</code> ，前者标识已经分配给用户使用的 chunk ，后者表示未使用的 chunk。</p>

<h3 id="allocated-chunk">Allocated chunk</h3>

<p>任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已经分配块和空闲块。大多数堆内存管理都将这些边界信息作为 chunk 的一部分嵌入到 chunk 内部，下图为 allocated chunk 的结构：</p>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/allocated_chunk.png" alt="allocated_chunk" /></p>

<p><code>size</code>：这部分包含了此处已分配的块的容量大小。</p>

<p>堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效，为了充分利用内存，堆管理奖这3个bit比特位用作chunk的标志位，最后三位包含以下信息：</p>

<ul>
<li><code>PREV_INUSE(P)</code> ——如果之前的块已经被分配，该位置1</li>
<li><code>IS_MMAPPED(M)</code> —— 如果块被映射，该位置1</li>
<li><code>NON_MAIN_ARENA(N)</code> —— 如果该快属于一个 <code>thread arena</code> ，该位置1</li>
</ul>

<p>请注意以下几点：</p>

<ul>
<li>allocated chunk 没有其他 <code>malloc_chunk</code> （比如 <code>fd — forward pointer，bk – back pointer</code>）。因此这部分区域会用来存储用户信息。</li>
<li>由于存储 <code>malloc_chunk</code> 需要一些额外的空间，用户请求的容量需要转换成实际需要的容量。转化不会改变最优 3 bits，因此它们用于存储关键信息。</li>
</ul>

<h3 id="free-chunk">Free Chunk</h3>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/free_chunk.png" alt="free_chunk" /></p>

<p>以下是空闲块各个部分内容的说明：</p>

<ul>
<li><code>prev_size</code>：不能同时调整两个空闲的块。当两个块都空闲时，它就会与一个单独的空闲块连接。因此前一个块及当前这个释放的块会被分配，同时 <code>prev_size</code> 包含前一个块的用户数据。</li>
<li><code>size</code>：这个部分包含有空闲块的 <code>size</code></li>
<li><code>fd</code>：Forward pointer —— 同一<code>bin</code>里指向下一块的指针（不是指向物理内存内的下一块）</li>
<li><code>bk</code>：Backward pointer —— 同一<code>bin</code>里指向前一块的指针（不是指向物理内存内的前一块）</li>
</ul>

<h2 id="bins">Bins</h2>

<p><code>bin</code> 是一种 <code>freelist</code> 数据结构，他们用来管理空闲的块。根据快的大小，以下为几不同的<code>bins</code>：</p>

<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>

<p>用来装载这些 <code>bins</code>的数据结构有：</p>

<ul>
<li><code>fastbinsY</code>：装有 fast bins 的数组</li>
<li><code>bins</code>：装有 unsorted, small, large bins 总共有126个，按照以下的规则被划分：

<ul>
<li>Bin 1 —— Unsorted bin</li>
<li>Bin 2 到 Bin 63 —— Small bin</li>
<li>Bin 64 到 Bin 126 —— Large bin</li>
</ul></li>
</ul>

<h3 id="fast-bin">Fast Bin</h3>

<p>大小在 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1249">16</a> 到 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600">80</a> bytes 的块叫做 <code>fast chunk</code> 。支持 <code>fast chunk</code> 的 bin 叫做 fast bins。在上述的这些 bin 里，fast bins 在内存分配和重新分配上更快。（译者注：只有 fast bin 是 LIFO 其他的 <code>bin</code> 都是 FIFO）</p>

<ul>
<li>Bins 的数量——10

<ul>
<li>每个 fast bin 包含由空闲块组成的单向链表。由于在 fast bins 里，在列表中间块不会被移除，所以使用单向链表。添加和删除都在列表末端进行 —— LIFO。</li>
</ul></li>
<li>块的大小 —— 以8 bytes累加

<ul>
<li>fast bin中的相邻的两个binlist中的块大小相差 8 bytes。举个例子，第一个 binlist 中块的大小为 16 bytes，第二 binlist 中块的大小为 24 bytes，依次类推。</li>
<li>在同一个 binlist 中块的大小相同</li>
</ul></li>
<li>在 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1778">malloc 初始化</a> 过程中，最大的 fast bin 的大小<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1795">设置</a>为 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L794">64</a> (!80) bytes。因此通过块的默认大小设置为 16 到 64 就可以将其划分为 fast chunks 了。</li>
<li>不能合并 —— 空闲的两个块可以相邻，但不能合并为一个空闲块。不能合并导致产生外存储碎片，但它可以大大提速！！</li>
<li><code>malloc(fast chunk)</code>

<ul>
<li>初始状态 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1765">fast bin</a> 的最大容积以及 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1680">fast bin 目录</a>是空的，因此即使用户请求一个 fast chunk，服务它的是 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3367">small bin code</a> 而不是 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3330">fast bin code</a>。</li>
<li>之后当它不再为空时， <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3332">计算</a> fast bin 目录以检索其对应的 binlist。</li>
<li>binlist 中第一个被找到的块会被<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3341">移除</a>并<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3355">返回</a>给用户。</li>
</ul></li>
<li><code>free(fast chunk)</code>

<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3887">计算</a> Fast bin 目录以检索其对应的 binlist。</li>
<li>该空闲块被添加到以上检索的 binlist 的最前端。</li>
</ul></li>
</ul>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/fast_bin.png" alt="fast_bin" /></p>

<h3 id="unsorted-bin">Unsorted Bin</h3>

<p>当小块或大块被释放时，它会被添加到 unsorted bin 里。 这给了 <code>glibc malloc</code> 再次利用最近释放的块的机会。因此内存分配以及回收的速度都会有所提升（因为 unsorted bin）由于排除了用于查找合适容器的时间。</p>

<ul>
<li>Bins 的数量——1

<ul>
<li>Unsorted bin 包含空闲块的一个循环双向链表（也称为 binlist 容器列表）</li>
</ul></li>
<li>块的大小 – 没有大小限制，任何大小的块都可以放入该 bin。</li>
</ul>

<p><img src="https://Hanfeng.ink/image/understand_glibc_malloc/small_bin.png" alt="samll_bin" /></p>

<h3 id="small-bin">Small bin</h3>

<p>小于 512 bytes 的块叫做 small chunk。 支持 small chunks 的容器叫做 small bins。 Small bins 在内存分配和回收时比 large bins 快（比 fast bins 慢）。</p>

<ul>
<li>Bins 的数量——62

<ul>
<li>每个 small bin 含有空闲块的一个双向循环链表。在这里使用双向链表的原因在于，在 small bins 里，需要从链表的中间取出块。在这里列表头部实现添加并在列表的后部删除 —— FIFO。</li>
</ul></li>
<li>块的大小 —— 以8 bytes累加

<ul>
<li>Small bin 中的相邻的两个binlist 中的块大小相差 8 bytes。举个例子，第一个 binlist 中块的大小为 16 bytes，第二 binlist 中块的大小为 24 bytes，依次类推。</li>
<li>在同一个 binlist 中块的大小相同</li>
</ul></li>
<li>合并 —— 两个相邻的空闲块，会被<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3964">合并</a>为一个空闲块。合并消除了外存储碎片，但是影响运行速度。</li>
<li><code>malloc(small chunk)</code>

<ul>
<li>初始状态下所有 small bins 都是 NULL，因此即使用户请求一个 small chunk，提供的是 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3432">unsorted bin code</a> 而不是 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3367">small bin code</a>。</li>
<li>在第一次调用 <code>malloc</code> 期间，在 malloc_state 里发现的 small bin 和 large bin 数据结构（<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1689">bins</a>）被初始化（即，<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3372">bins 会指向它自己</a>表示他们是空的）。</li>
<li>之后当 small bin 处于非空状态时，其对应 binlist 中的最后一个块会被<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3372">移除</a>并<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3393">返回</a>给用户。</li>
</ul></li>
<li><code>free(small chunk)</code>

<ul>
<li>释放块时，查看其前一个或下一个块是否空闲，如果空闲就合并（即，从他们各自的链表里解除块的链接，然后在 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3995">unsorted bin</a> 的链表最开端添加新的合并后的块）。</li>
</ul></li>
</ul>

<h3 id="large-bin">Large bin</h3>

<p>大小大于等于 512 bytes 的块称为 large chunk。支持 large chunks 的 bins 叫作 large bins。Large bins 在内存分配和回收中比 small bins 要慢。</p>

<ul>
<li>Bins 的数量——63

<ul>
<li>每个 large bin 是由空闲块组成的双向循环链表。在 large bins 里，使用双向循环链表的原因是，我们需要在任意位置增加或删除块。</li>
<li>在这 63 个 bins之外的情况：</li>
<li>32 个 bins 中，相邻的两个binlist 中的块大小相差 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1478">64 bytes</a> 。</li>
<li>16 个 bins 中，相邻的两个binlist 中的块大小相差 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1479">512 bytes</a> 。</li>
<li>8 个 bins 中，相邻的两个binlist 中的块大小相差 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1480">4096 bytes</a> 。</li>
<li>4 个 bins 中，相邻的两个binlist 中的块大小相差 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1481">32768 bytes</a> 。</li>
<li>2 个 bins 中，相邻的两个binlist 中的块大小相差  <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1482">262144 bytes</a>。</li>
<li>1 个 bin，剩余的所有容量都在一个块中。</li>
<li>不同于 small bin，在 large bin 里的块大小是不同的。因此他们以降序排列。最大的块在最前端而最小的块被排到 binlist 的末尾。</li>
</ul></li>
<li>合并 —— 两个相邻的空闲块，会<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3964">合并</a>为一个空闲块。</li>
<li><code>malloc(large chunk)</code>

<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3571">初始化状态</a>下所有 large bins 都是 NULL，因此即使用户请求一个 large chunk，提供的是<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3639">下一个最大的 bin code</a> ，而不是 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3566">large bin code</a>。</li>
<li>同样在第一次调用 <code>malloc</code> 期间，在 malloc_state 里发现的 small bin 和 large bin 被 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3411">初始化</a>。即，bins 会指向它自己表示它们是空的。</li>
<li>此后当 large bin 不为空时，如果最大块的大小（在它的容器列表里）<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3571">比用户请求的容量还大</a>， binlist 会从 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3575">尾部到头部</a>，来查找一个大小接近或等于用户请求大小的合适的块。一旦找到，这个块将分裂为两个块。</li>
<li>用户块（容量为用户请求的大小）—— 返回给用户。</li>
<li>剩余块（容量为剩余容量的大小）—— 添加到 unsorted bin。</li>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3571">如果最大块的大小（在它的容器列表里）小于用户请求的大小</a>，那么尽量使用下一个最大（非空）bin 为用户的请求提供服务。下一个最大的 bin code 会<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3648">扫描</a>容器映射来查找下一个最大的非空 bin ，如果<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3682">找到</a>任何一个，从 binlist 里检索到了一个合适的块，<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3687">分裂</a>并返回给用户。如果没找到，尝试使用 Top Chunk 为用户请求提供服务。</li>
</ul></li>
<li><code>free(large chunk)</code> —— 过程与 <code>free(small chunk)</code> 类似</li>
</ul>

<h3 id="top-chunk">Top Chunk</h3>

<p>处于 <code>arena</code> 顶部的块叫做 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1683">top chunk</a>。它不属于任何 bin。而是在系统当前的所有 free chunk 都<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3739">无法满足用户请求</a>)的内存大小的时候，将此 chunk 分配给用户使用。如果 top chunk <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3760">比用户请求的容量要大</a>，top chunk 将会分为两个块：</p>

<ul>
<li>用户请求的 chunk</li>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3762">剩余的部分为新的 top chunk</a></li>
</ul>

<p>如果内存空间不足，top chunk 使用 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L2458">sbrk</a> (<code>main arena</code>) 或 <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L2390"><code>mmap</code></a> (<code>thread arena</code>)系统调用来<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3790">扩展</a>内存空间。</p>

<h3 id="last-remainder-chunk">Last Remainder Chunk</h3>

<p>last remainder chunk 是由最近一次请求，对块进行分裂而产生的。last remainder chunk 加强了引用的局部性（即，连续的 <code>malloc small chunk</code>  获取的空间可能彼此相邻）。</p>

<p>但是除了在一个 <code>arena</code> 里可利用的的块，哪些块有资格成为 last remainder chunk？</p>

<p>当用户请求一个small chunk，且该请求无法被 small bin，unsorted bin 满足的时候，就通过 bin maps 遍历合适的 chunk，如果该 chunk 有剩余部分的话，就将剩余部分变成一个新的 chunk 加入到 unsorted bin 中，另外，再将该新的 chunk <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3721">变成新的last remainder chunk</a>。</p>

<p>那么如何使引用存在局部性？</p>

<p>当用户请求一个small chunk，且该请求无法被 small bin满足，那么就转而交由 unsorted bin处理。同时，假设当前 unsorted bin 中<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3449">只有一个 chunk 的话</a>——就是last remainder chunk，那么就将 chunk <a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3455">分成两部分</a>：前者分配给用户，剩下的部分放到 unsorted bin 中，并成为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3458">新的 last remainder chunk</a>。这个就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高内存分配的局部性。</p>
                        </div>

                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="https://Hanfeng.ink/post/gdb_debug_info/">调试器工作原理：第三部分 调试信息</a></li>
        
        <li><a href="https://Hanfeng.ink/post/gdb_breakpoint/">调试器工作原理：第二部分 断点</a></li>
        
        <li><a href="https://Hanfeng.ink/post/gdb_basic/">调试器工作原理：第一部分 基础</a></li>
        
        <li><a href="https://Hanfeng.ink/post/os_compiler_map/">操作系统 &amp; 编译原理 学习攻略</a></li>
        
        <li><a href="https://Hanfeng.ink/post/python_performance/">Python代码性能优化方法总结</a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            <ul class="clearfix">
                                
                                <li><a href="https://Hanfeng.ink/tags/%E5%86%85%E5%AD%98">内存</a></li>
                                
                                <li><a href="https://Hanfeng.ink/tags/%E7%BF%BB%E8%AF%91">翻译</a></li>
                                
                            </ul>
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://Hanfeng.ink/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://Hanfeng.ink/post/coroutine/" title="协程简介">协程简介</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/understand_glibc_malloc/" title="深入理解 malloc">深入理解 malloc</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/gdb_debug_info/" title="调试器工作原理：第三部分 调试信息">调试器工作原理：第三部分 调试信息</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/gdb_breakpoint/" title="调试器工作原理：第二部分 断点">调试器工作原理：第二部分 断点</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/gdb_basic/" title="调试器工作原理：第一部分 基础">调试器工作原理：第一部分 基础</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/os_compiler_map/" title="操作系统 &amp; 编译原理 学习攻略">操作系统 &amp; 编译原理 学习攻略</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/python_performance/" title="Python代码性能优化方法总结">Python代码性能优化方法总结</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/arsenal/" title="Arsenal（长期更新）">Arsenal（长期更新）</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/bitwise/" title="Leetcode 137 —— 位操作解法">Leetcode 137 —— 位操作解法</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/post/thread/" title="线程简介">线程简介</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://Hanfeng.ink/categories/python/">python(3)</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统(8)</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法(3)</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习(4)</a>
    </li>
    
    <li>
        <a href="https://Hanfeng.ink/categories/%E6%9D%82%E8%AE%B0/">杂记(2)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://Hanfeng.ink/tags/c%E8%AF%AD%E8%A8%80/">c语言</a>
    
    <a href="https://Hanfeng.ink/tags/leetcode/">leetcode</a>
    
    <a href="https://Hanfeng.ink/tags/linux/">linux</a>
    
    <a href="https://Hanfeng.ink/tags/python/">python</a>
    
    <a href="https://Hanfeng.ink/tags/%E4%BC%98%E5%8C%96/">优化</a>
    
    <a href="https://Hanfeng.ink/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/">位操作</a>
    
    <a href="https://Hanfeng.ink/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/">信息论</a>
    
    <a href="https://Hanfeng.ink/tags/%E5%86%85%E5%AD%98/">内存</a>
    
    <a href="https://Hanfeng.ink/tags/%E5%88%86%E7%B1%BB/">分类</a>
    
    <a href="https://Hanfeng.ink/tags/%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B/">判别模型</a>
    
    <a href="https://Hanfeng.ink/tags/%E5%8E%86%E5%8F%B2/">历史</a>
    
    <a href="https://Hanfeng.ink/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    
    <a href="https://Hanfeng.ink/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    
    <a href="https://Hanfeng.ink/tags/%E6%96%87%E5%AD%A6/">文学</a>
    
    <a href="https://Hanfeng.ink/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%89%B9%E5%BE%81%E5%80%BC%E5%88%86%E8%A7%A3/">特征值分解</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/">生成模型</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%AE%97%E6%B3%95/">算法</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
    
    <a href="https://Hanfeng.ink/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
    
    <a href="https://Hanfeng.ink/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
    
    <a href="https://Hanfeng.ink/tags/%E8%BF%9B%E7%A8%8B/">进程</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://Hanfeng.ink/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2018 <a href="https://Hanfeng.ink/">寒枫的博客 By Hanfeng Zhang</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="https://Hanfeng.ink/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="https://Hanfeng.ink/js/totop.js?v=0.0.0" async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-134764313-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




  <script src="https://Hanfeng.ink/js/douban.js"></script>

</body>
</html>
